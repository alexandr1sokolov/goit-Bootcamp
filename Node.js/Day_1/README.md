## День_1
##### Начало работы с Node.js
##### Использование NPM
##### Понимание асинхронного программирования
##### Ваш первый сервер на Node.js
##### Работа с базами данных

### Знакомство с Server-side JavaScript
Изначально  JavaScript запускался в браузере, осуществлялось посредством “движка” v8.

Чтобы ваш JavaScript код выполнился на вычислительной машине вне браузера (на backend), он должен быть интерпретирован и, конечно же, выполнен. Именно это и делает Node.js. Для этого он использует движок V8 VM от Google — ту же самую среду исполнения для JavaScript, которую использует браузер Google Chrome.

Кроме того, Node.js поставляется со множеством полезных модулей, так что вам не придется писать всё с нуля, как, например, вывод строки в консоль.

Таким образом, Node.js состоит из 2 вещей: среды исполнения и полезных библиотек.

Проверяем версию -  node -v //получаем текущую версию
Доступны многие методы, за исключением Alert и работы с DOM-деревом, но можно вызвать привычное console.log

Первый — без аргументов: данная команда откроет интерактивный режим в командной строке, где вы можете исполнять код JavaScript.$ node > console.log(‘Hello World’); Hello World undefined

В этом примере я просто набрал “console.log(‘Hello World’);” и нажал на Enter. Node начнет выполнять, и мы увидим наше сообщение. Также он напишет “undefined”, потому что печатает возвращаемое значение, и console.log не возвращает ничего.   — Другой способ использования Node.js — это создание файла Javascript.

Откройте ваш любимый редактор и создайте файл под названием helloworld.js. Мы хотим вывести строку «Hello world» в консоль, для этого пишем следующий код:
`console.log("Hello World");`
Сохраняем файл и выполняем его посредством Node.js:
`node helloworld.js`

Это должно вывести Hello World на наш терминал.

### Задачи, которые должен реализовывать сервер.
У нас — онлайн веб-приложение, поэтому нам нужен HTTP-сервер;

- Нашему серверу необходимо обслуживать различные запросы в зависимости от URL, по которому был сделан запрос. Для этого нам нужен какой-нибудь роутер (маршрутизатор) - он у нас уже есть в React, чтобы иметь возможность направлять запросы определенным обработчикам;

- Для выполнения запросов, пришедших на сервер и направляемые роутером, нам нужны действующие обработчики запросов;

- Роутер, вероятно, должен иметь дело с разными входящими POST-данными и передавать их обработчикам запросов в удобной форме. Для этого нам нужен какой-нибудь обработчик входных данных;

- Мы хотим не только обрабатывать запросы, но и показывать пользователю контент по запрошенным URL-адресам, поэтому нам нужна некая логика отображения для обработчиков запросов, чтобы иметь возможность отправлять контент пользовательскому браузеру;

- Последнее, но не менее важное — пользователь сможет загружать данные, поэтому нам нужен какой-нибудь обработчик загрузки, который возьмёт на себя заботу о деталях.

### Файлы ввода/вывода с node.js
К счастью, Node.js сильно облегчает обработку содержания файла с помощью встроенного модуля filesystem (fs). Модуль fs имеет функцию readFile, которая берёт путь к файлу и обратный вызов. Обратный вызов будет исполнен, когда файл будет полностью прочитан. Данные файла попадают в форме типа Buffer, что является набором битов.

```javascript
//hello.js
const fs = require('fs')

fs.readFile('hello.txt', 'utf8', (error, content) =>
  content
    .split('\n')
    .filter(line => line.includes('dog'))
    .forEach(line => console.log(line))
)
```

```
//hello.txt

fluffykins is a dragon
wolfbane is a dragon
kittylunch is a cat
karo is a dog
multidog is a dog
```

### Асинхронные вызовы в node.js
Для Node.js характерно использование асинхронных вызовов. По существу вы пишете, что нужно делать, и когда это будет сделано, будет вызван обратный вызов, потому что node.js однопоточен. Пока вы ждёте запуска обратного вызова, Node.js может уйти и делать другие вещи вместо блокировки до завершения запроса.
Это особенно важно для веб-серверов. Довольно характерно для современных веб-приложений иметь доступ к базам данных. Пока вы ждёте возвращения результата от базы данных, Node может обрабатывать больше запросов. Это позволяет справляться с тысячами параллельных запросов с маленькими накладными расходами по сравнению с созданием отдельного потока для каждого соединения.

Создание веб-сервера с помощью node.js
Как было уже сказано, Node ничего не может делать сам по себе. Один из встроенных модулей позволяет легко создать простой HTTP сервер, 
```javascript
//server.js
const http = require('http'); // require('http2'); require('https'); 
// дока на протоколы структуры файлов таких как .xml .svg ipv4 ipv6 ftp и многое другое 
//  RFC HTTP    ---  https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_RFC
const server = http.createServer(function (req, res) {
console.log("Request received.");
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(8080);
console.log('Server running on port 8080.');
```
Ещё раз: это базовый веб-сервер, а не сервер с полным функционалом. Он не может обслуживать картинки или HTML-файлы. На самом деле, какой бы вы ни отправили запрос, он возвратит “Hello World”. Однако, вы можете запустить этот скрипт, перейти по адресу http://localhost:8080 в своем браузере и увидеть этот текст.

`$ node server.js`
 
Первая строка подключает http-модуль, который поставляется вместе с Node.js и делает его доступным через переменную http.

Далее, мы вызываем одну из функций http-модуля createServer. Эта функция возвращает объект, имеющий метод listen, принимающий числовое значение порта нашего HTTP-сервера, который необходимо прослушивать.
Мы создаем сервер и передаём функцию в созданный им метод. Всякий раз, когда наш сервер получает запрос, переданная нами функция будет вызываться.

Этот принцип называется обратный вызов или callback. Мы передаём в некоторый метод функцию и этот метод исполняет её, когда происходит связанное с методом событие.

Обратите внимание, что я использую console.log для вывода текста «Request received.», когда срабатывает функция (наш callback), а текст «Server running on port 8080» — сразу после запуска HTTP-сервера.

Когда мы запустим этот код (как обычно, node server.js), он тут же выведет в командной строке «Server running on port 8080». Всякий раз, когда мы делаем запрос нашему серверу (через переход по адресу http://localhost:8888/ в нашем браузере), в командной строке выводится сообщение «Request received.»

Объектно-ориентированный асинхронный серверный JavaScript с callback-ми в действии :-)

(Обратите внимание, что наш сервер, возможно, будет выводить «Request received.» в консоль 2 раза при открытии страницы в браузере. Это происходит из-за того, что большинство браузеров будут пытаться загрузить фавикон по адресу http://localhost:8888/favicon.ico при запросе http://localhost:8888/) 

Когда запускается наша функция и срабатывает, в неё передаются 2 параметра: request и response.

Они являются объектами и вы можете использовать их методы для обработки пришедшего HTTP-запроса и ответа на запрос (то есть, просто что-то посылать по проводам обратно в браузер, который запрашивал ваш сервер).

И наш код делает именно это: Всякий раз, когда запрос получен, он использует функцию response.writeHead() для отправки HTTP-статуса 200 и Content-Type в заголовке HTTP-ответа, а функцию Response.Write() или res.end для отправки текста «Hello World» в теле HTTP-ответа.
response.end() вызывается, чтобы завершить наш ответ.

На данный момент, мы не заботимся о деталях запроса, поэтому мы не используем объект request полностью.

### Модульность для вашего приложенияМодульность для вашего приложения
Теперь у вас есть файл index.js, поэтому пришло время перейти на следующий уровень! Давайте создадим что-то более сложное, разделив наш исходный код на несколько JavaScript-файлов с целью удобочитаемости и поддерживаемости. Чтобы начать работу, вернитесь в свою IDE и создайте следующую структуру каталогов (с пустыми файлами), но пока не трогайте package.json, мы сгенерируем его автоматически на следующем шаге:
├── app
|  ├── server.js| 
├── index.js
└── package.json


Каждый проект Node.js начинается с создания файла package.json. Вы можете думать о нем как о JSON-представлении приложения и его зависимостей. Он содержит имя вашего приложения, автора (вас) и все зависимости, необходимые для запуска приложения. Мы рассмотрим раздел зависимостей позже в главе «Использование NPM».

Вы можете интерактивно генерировать файл package.json с помощью команды npm init в терминале. После запуска команды вас попросят ввести некоторые данные, например имя вашего приложения, версию, описание и так далее. Не нужно беспокоиться, просто нажимайте Enter, пока не получите сформированный JSON и вопрос is it ok?. Нажмите Enter в последний раз и вуаля: ваш package.json был автоматически сгенерирован и помещен в папку вашего приложения. Если вы откроете этот файл в своей IDE, он будет очень похож на фрагмент кода ниже.
// package.json
{
  "name": "@NadyaHristuk",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js"
  },
  "author": "", "license": "ISC"
}
Хорошей практикой является добавление стартового скрипта в ваш пакет package.json.

 // index.js
`require('./app/server')`

Вставьте этот код в файл server.js в каталоге /app.

`module.exports.server = server`

Чтобы проверить, всё ли вы сделали правильно, сохраните эти файлы, откройте терминал и введите npm start или node index.js.

Как только вы это сделаете, как показано в примере выше, вы можете запустить приложение с помощью команды npm start. Это очень удобно, когда вы хотите развернуть свое приложение у PaaS-провайдера: они могут распознать команду start и использовать её для запуска приложения.Теперь создадим  файл под названием index.js.
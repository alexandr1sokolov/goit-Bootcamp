const express = require('express'); // получаем модуль Express
const app = express(); // создаем приложение, создает объект приложения.
const productRouter = require('./api/routes/products');
const orderRouter = require('./api/routes/orders');
const userRouter = require('./api/routes/users');
const checkAuth = require('./api/middleWares/middleWares')
app.use(express.json()); //мидлвеэре. смотрит и вызывает
app.use(express.urlencoded()); //проверяет там смотрит что там и вызывает
//Для каждого типа запросов здесь определен свой обработчик Express. Когда приходит GET-запрос к приложению, то возвращаем в ответ клиенту все документы из базы данных:

app.get('/', function (req, res, next) {
    res.sendFile(__dirname + '/static/index.html')

})
app.use('/orders', orderRouter);
app.use('/products', productRouter); // обрабатываем и отдаем ответ и поэтому метод некст не вызывамем// устанавливаем обработчик для маршрута "/"
app.use('/users', userRouter);
module.exports = app; //Чтобы какие переменные или функции модуля были доступны, необходимо определить их в объекте module.exports. Объект module.exports - это то, что возвращает функция require() при получении модуля.

// NPM (Node Package Manager)

//Первый параметр функции - маршрут, а второй - функция, которая будет обрабатывать запрос по этому маршруту.

//Флаг --save указывает, что информацию о добавленном пакете надо добавить в файл package.json.

//Флаг --save-dev указывается, что информацию о пакете следует сохранить в секции devDependencies файла package.json:

//Информация обо всех добавляемых пакетах, которые используются при запуске приложения, добавляется в секцию dependencies.

//devDependencies

//Кроме пакетов, которые применяются в приложении, когда оно запущено, например, express, то есть в состоянии "production", есть еще пакеты, которые применяются при разработке приложения и его тестировании. Такие пакеты добавляются в другую секцию - devDependencies

//Для асинхронного чтения файла применяется функция fs.readFile:

//fs.readFile("hello.txt", "utf8", function(error,data){ });
//Первый и второй параметр функции опять же соответственно путь к файлу и кодировка. А в качестве третьего параметра передается функция обратного вызова, которая выполняется после завершения чтения. Первый параметр этой функции хранит информацию об ошибке при наличии, а второй - собственно считанные данные.

//И здесь стоит обратить внимание, что несмотря на то, что функция fs.readFile() вызывается первой, но так как она асинхронная, она не блокирует поток выполнения, поэтому ее результат выводится в самом конце.

//Подавляющее большинство функционала Node.js применяет асинхронную событийную архитектуру, которая использует специальные объекты - эмиттеры для генерации различных событий, которые обрабатываются специальными функциями - обработчиками или слушателями событий. Все объекты, которые генерируют события, представляют экземпляры класса EventEmitter.

//С помощью функции eventEmitter.on() к определенному событию по имени цепляется функция обработчика. Причем для одного события можно указать множество обработчиков. Когда объект EventEmitter генерирует событие, происходит выполнение всех этих обработчиков.

/*var Emitter = require("events");
var emitter = new Emitter();
var eventName = "greet";
emitter.on(eventName, function(){
    console.log("Hello all!");
});
 
emitter.on(eventName, function(){
    console.log("Привет!");
});
 
emitter.emit(eventName);
Весь необходимый функционал сосредоточен в модуле events, который необходимо подключить. С помощью функции on() связываем событие, которое передается в качестве первого параметра, с некоторой функцией, которая передается в качестве второго параметра. В данном случае событие называется "greet".

Для генерации события и вызова связанных с ним обработчиков выполняется функция emitter.emit(), в которое передается название события.*/

//Параметры request и response, которые передаются в функцию и с помощью которых мы можем получать данные о запросе и управлять ответом, как раз представляют собой потоки: request - поток для чтения, а response - поток для записи.

//http.createServer(function(request, response){

/*       response.end("Hello world!");
}).listen(3000);
Эта функция принимает два параметра:
request: хранит информацию о запросе
response: управляет отправкой ответа
Request
Параметр request позволяет получить информацию о запросе и представляет объект http.IncomingMessage. Отметим некоторые основные свойства этого объекта:
headers: возвращает заголовки запроса
method: тип запроса (GET, POST, DELETE, PUT)
url: представляет запрошенный адрес*/

/*Response
Параметр response управляет отправкой ответа и представляет объект http.ServerResponse. Среди его функциональности можно выделить следующие методы:
statusCode: устанавливает статусный код ответа
statusMessage: устанавливает сообщение, отправляемое вместе со статусным кодом
setHeader(name, value): добавляет в ответ один заголовок
write: пишет в поток ответа некоторое содержимое
writeHead: добавляет в ответ статусный код и набор заголовков
Например, изменим файл app.js следующим образом:*/

//Для обработки запросов в Express определено ряд встроенных функций, и одной из таких является функция app.get(). Она обрабатывает GET-запросы протокола HTTP и позволяет связать маршруты с определенными обработчиками. Для этого первым параметром передается маршрут, а вторым - обработчик, который будет вызываться, если запрос к серверу соответствует данному маршруту:

//app.get("/", function(request, response)

/*Функция, которая передается в app.use(), принимает три параметра:

request: данные запроса

response: объект для управления ответом

next: следующая в конвейере обработки функция

Каждая из функций middleware просто выводит на консоль сообщение и в конце вызывает следующую функцию с помощью вызова next().*/

/*app.get("/contact", function(request, response){
     
    response.send("<h1>Контакты</h1>");
});
app.listen(3000);
Когда приходит запрос Express сопоставляет запрошенный адрес с каждым из маршрутов. При совпадении маршрута вызывается его функция обработчика.*/

/*Передача параметров в маршруте
Маршруты могут содержать параметры - именованные сегменты URL-адреса. Название параметра должно включать символы из диапазона [A-Za-z0-9_]. В определении маршрута параметры предваряются знаком двоеточия:

var express = require("express");
 
var app = express();
 
app.get("/products/:productId", function (request, response) {
  response.send("productId: " + request.params["productId"])
});
 
app.listen(3000);
В данном случае параметр называется "productId". Через коллекцию request.params можно получить все параметры и, в частности, значение параметра productId.*/

//В саму же функцию express.static() передается путь к папке со статическими файлами. Специальное выражение __dirname позволяет получить полный путь к папке.

//Для получения самих отправленных данных используем выражения типа request.body.userName, где request.body инкапсулирует данные формы, а userName - ключ данных, который соответствует значению атрибута name поля ввода на html-странице:

//поскольку с клиентом мы взаимодействуем через формат json, то данные клиенту отправляются с помощью метода response.json()

//Для обработки запросов определено пять методов для каждого типа запросов: app.get()/app.post()/app.delete()/app.put()

//Здесь также для поиска изменяемого объекта считываем данные из файла, находим изменяемого пользователя по id, изменяем у него свойства и сохраняем обновленные данные в файл.

//Таким образом, мы определили простейший API. Теперь добавим код клиента. Итак, как установлено в коде, Express для хранения статических файлов использует папку public, поэтому создадим в проекте подобную папку. В этой папке определим новый файл index.html, который будет выполнять роль клиента. В итоге весь проект будет выглядеть следующим образом:

//И поскольку Express в качестве хранилища статических файлов использует папку public, то при обращении к приложению по корневому маршруту http://localhost:3000 клиент получит данный файл.
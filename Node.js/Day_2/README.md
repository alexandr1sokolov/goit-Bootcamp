# Node.js

##### День 2
1. Работа с Express
2. Routing
3. Postman

- [Ссылка на теорию - день 2](http://# "Ссылка на теорию - день 2ы")
- [Ссылка на код - день 2](http://# "Ссылка на код - день 2")

## Express node js
Предварительная подготовка

Мы познакомимся с фреймворком **express**. Реализуем базовый вебсервер и опишем роуты для списка исполнителей и конкретного исполнителя.

Express — один из лучших фреймворков для Node. Он имеет отличную поддержку со стороны разработчиков и кучу полезных функций. 

В основе фреймворка Express лежит Connect. Это набор middleware-функций, которое поставляется вместе с множеством полезных вещей. Если Вам интересно, что же такое middleware-функция, вот Вам небольшой пример:

```javascript
//javascript
var connect = require('connect'),
    http = require('http');
 
var app = connect()
    .use(function(req, res, next) {
        console.log("That's my first middleware");
        next();
    })
    .use(function(req, res, next) {
        console.log("That's my second middleware");
        next();
    })
    .use(function(req, res, next) {
        console.log("end");
        res.end("hello world");
    });
http.createServer(app).listen(3000);
```
Middleware-функцией в основном зовётся функция, которая принимает в качестве параметров request и responce-объекты, а также callback-функцию, которая будет вызвана следующей. 

Каждая middleware-функция решает: либо ответить, используя responce-объект, либо передать поток следующей callback-функции. 

В примере выше, если Вы уберёте вызов метода next() во второй функции, строка “hello world” никогда не будет отправлена клиенту. 

В целом, именно как работает Express. В нём есть несколько предопределённых middleware-функций, которые, несомненно, сэкономят Вам кучу времени. 

Таковой, например, является Body-парсер, разбирающий тело запроса и поддерживающий типы содержимых application/json, application/x-www-form-urlencoded и multipart/form-data. 

Или Cookie-парсер, который разбирает куки-заголовки и заполняет поле req.cookies объектом, ключом которого будет имя куки.

Фактически, Express обёртывает собой Connect-фреймворк, дополняя его некоторой функциональностью, такой, например, как логика маршрутизации, которая делает прохождение процесса маршрутизации более гладким. Ниже приведён пример обработки GET-запроса:

```javascript
app.get('/hello.txt', function(req, res){
    var body = 'Hello World';
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('Content-Length', body.length);
    res.end(body);
});
```

### Начало работы с Express

Итак я создал пустую папку под наш проект. Первое, что необходимо сделать, это создать файл package.json. Это файл, в котором мы храним список установленных пакетов и их версии. Когда вы захотите развернуть ваш проект на новой машине или дать проект другому девелоперу, одной команды npm install будет достаточно, чтобы установить все зависимости, которые необходимы для проекта.

##### Для создания файла package.json автоматически напишем
`npm init`
на все вопросы жмем enter.

Если мы откроем файл package.json, то он практически пустой. В нем указан автор, версия и другая общая информация.

##### Теперь давайте установим express
`npm install express`

Эта команда установила нам express и все его зависимости в package.json. Если мы посмотрем в него, то увидим, что у нас создался обьект dependencies, где указан express и его установленная версия.

Также в проекте у нас создалась директория node_modules. Это папка, где хранятся все библиотеки установленные с помощью npm.

##### Теперь давайте создадим файл server.js, который будет нашим сервером.
Для начала нам нужно подключить библиотеку express. Делается это с помощью слова require. В данном случае оно подключит пакет express из папки node_modules.
`var express = require('express');`

##### Дальше нам необходимо создать переменную app, которая и будет являтся нашим сервером.
`var app = express();`

##### Теперь мы обьявить роут для нашего приложения. Описывая роут, мы описываем, что будет происходить, когда мы зайдем на определенный урл.
```javascript
app.get('/', function (req, res) {
  res.send('Hello API');
});
```
Здесь мы описали, что мы хотим описать роут /, и когда мы будем на него заходить, то нам на странице будет выводиться Hello API. req - это request, а res - это response. И мы вызываем функцию end, чтобы закончить ответ и вывести строку на екран.

Теперь нам нужно настроить сервер, чтобы он был запущен на определенном порту. Для этого добавим

```javascript
app.listen(3012, function () {
  console.log('API app started')
})
```
Это запустит сервер на 3012 порту и когда он запустится выведет в консоль console.log.

##### Теперь если мы в консоли напишем node server.js, то у нас запустится сервер и выведется в консоль API app started.

Теперь если мы откроем в браузере http://localhost:3012, то у нас выведется на страницу Hello API.

Мы с вами будем делать API музыкальных исполнителей. И уже сейчас мы можем добавить роут, который будет возвращать нам список исполнителей.

Давайте создадим массив исполнителей, который пока будет статическим и опишем роут /artists для него.

Артистов мы будем хранить как массив обьектов с ID и названиями.
```javascript
var artists = [
  {
    id: 1,
    name: 'Metallica'
  },
  {
    id: 2,
    name: 'Iron Maiden'
  },
  {
    id: 3,
    name: 'Deep Purple'
  }
];
```

и добавим роут
```javascript
app.get('/artists', function (req, res) {
  res.send(artists);
});
```
в котором отдадим описаных исполнителей.

Не забывайте также о том, что мы с вами еще не реализовали автоматической перезагрузки сервера при изменении файлов. Это значит, что каждый раз, когда вы сделали изменение вам нужно остановить вебсервер с помощь ctrl+c либо command+c и запустить заново.

Если мы перезапустим вебсервер и зайдем на http://localhost:3012/artists, то увидим что у нас отрендерился спсок исполнителе.

Как вы видите у меня он красиво выглядит, а у вас скорее всего он отображается просто как текст в одну строчку.

Для красивого отображения JSON вы можете в google chrome установить плагин JSON Viewer.

Теперь давайте опишем роут, который будет возвращать отдельного исполнителя. Для того, чтобы описать урл вида /artists/1 нам необходимо вместо 1 задать динамический параметр.

```javascript
app.get('/artists/:id', function (req, res) {
  res.send('test');
});
```
Теперь что бы мы не писали вместо id, у нас всегда будет срабатывать этот обработчик. Получить значение динамического id можно из req.params, где содержатся все параметры. Давайте законсолим req.params.

И теперь давайте найдем необходимого исполнителя в массиве
```javascript
app.get('/artists/:id', function (req, res) {
  var artist = artists.find(function (artist) {
    return artist.id === Number(req.params.id);
  })
  console.log(artist);
  res.send(artist);
});

```
Мы использовали обычный find из javascript, чтобы найти обьект в массиве. Единственный нюанс в том, что все параметры из урла являются строками. А наши ID это Number. Поэтому мы приводим req.params.id к Number.

Итак в этом уроке мы познакомились с фреймворком express. Реализовали базовый вебсервер и описали роуты для списка исполнителей и конкретного исполнителя.

### Системой управления базами данных будет Express. Кроме того, в качестве вспомогательного средства для работы с JSON, используем пакет **body-parser**.
Установим всё это:

`npm install body-parser`

### Что делает body-parser с выражением  в Express?

Он анализирует тело запроса HTTP. Это обычно необходимо, когда вам нужно знать больше, чем только URL-адрес, который вы нажимаете, особенно в контексте HTTP-запроса POST или PUT PATCH, где информация, которую вы хотите, содержится в теле.

В основном это промежуточное программное обеспечение для разбора JSON, обычного текста или просто возврата необработанного объекта Buffer, с которым вам нужно иметь дело, как вам нужно.

body-parser извлекает всю часть тела входящего потока запросов и предоставляет его на **req.body.**

Среднее программное обеспечение ранее было частью Express.js, но теперь вы должны установить его отдельно.

Этот модуль **body-parser** анализирует данные JSON, буфера, строки и URL-адреса, переданные с использованием запроса HTTP POST. 

**body-parser** извлекает всю часть тела входящего потока запросов и предоставляет его на **req.body** как нечто более легкое для взаимодействия. 

Вам это не нужно само по себе, потому что вы могли бы все это сделать сами. Тем не менее, он, скорее всего, сделает то, что вы хотите, и избавит вас от неприятностей.

Пойти немного глубже; **body-parser** дает вам промежуточное программное обеспечение, которое использует nodejs/zlib, чтобы разархивировать входящие данные запроса, если он заархивирован и stream-utils/raw-body, чтобы дождаться полного, необработанного содержимого тела запроса до "разбора" (это означает, что если вы не собираетесь использовать тело запроса, вы просто теряете некоторое время).

После получения необработанного содержимого **body-parser** проанализирует его с использованием одной из четырех стратегий в зависимости от конкретного промежуточного программного обеспечения, которое вы решили использовать:

**bodyParser.raw()**: фактически не анализирует тело, а просто выводит содержимое буферизованного содержимого из a Buffer в **req.body**.

**bodyParser.text()**: Читает буфер как обычный текст и предоставляет результирующую строку на **req.body**.

**bodyParser.urlencoded()**: анализирует текст в виде URL-кодированных данных (так как браузеры, как правило, отправляют данные формы из регулярные формы, установленные в POST) и выдает результирующий объект (содержащий ключи и значения) на req.body. Для сравнения; в PHP все это автоматически выполняется и отображается в $_POST.

**bodyParser.json()**: Разбирает текст как JSON и выдает результирующий объект на **req.body**.

Только после установки **req.body** в желаемое содержимое он вызовет следующее промежуточное программное обеспечение в стеке, которое затем сможет получить доступ к данным запроса, не задумываясь о том, как его распаковать и проанализировать.

Вы можете обратиться к **body-parser** github, чтобы прочитать их документацию, в нем содержится информация о его работе.Вы можете обратиться к body-parser github, чтобы прочитать их документацию, в нем содержится информация о его работе.

#### Ещё, я очень рекомендую установить Nodemon как dev-зависимость. Это простой маленький пакет, который, при изменении файлов, автоматически перезапускает сервер.

### Перезагружаем node с помощью nodemon

Абсолютно у всех разработчиков знакомство с nodejs начинается с того, что после каждого изменения нужно перезагружать сервер. Поэтому, в этом видео мы разберем, как сделать так, чтобы сервер перегружался автоматически.

Самый популярный вариант - это **nodemon**. То есть идея состоит в том, что в development окружении мы хотим, чтобы **nodemon** следил за файлами, которые мы меняем и просто перезапускал сервер, если эти файлы относятся к серверу.

Cейчас есть пустой проект с server.js, куда установили nodemon.

###### В документации nodemon первой строчкой идет, что вы можете установить его глобально. Пожалуйста, не ставьте никогда пакеты глобально. Все нужные пакеты должны быть внутри, а не снаружи. Ни один разработчик не хочет склонировать проект, а потом сидеть и разбираться, а какие же внешние зависимости и каких версий ему требуются.

Для установки этого пакета выполните команду:

`npm install --save-dev nodemon`

Затем можно добавить следующий скрипт в файл package.json:

```javascript
// package.json
  "scripts": {
    "dev": "nodemon server.js"
  },

```
Как мы видим он запустился. Нам вывелось, что он вотчит все файлы в нашей папке и запускает команду node server.js при изменении любого файла.

Теперь, если мы изменим наш server.js, то nodemon перезапустит сервер.

Готовый package.json будет выглядеть примерно так:

```javascript
// package.json
{
  "name": "notable",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "dev": "nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.15.2",
    "express": "^4.14.0",
    "mongodb": "^2.2.16"
  },
  "devDependencies": {
    "nodemon": "^1.11.0"
  }
}
```

Теперь создадим файл *server.js* и приступим к работе.

## API
CRUD is an acronym for Create, Read, Update and Delete. It is a set of operations we get servers to execute (POST, GET, PUT and DELETE respectively). This is what each operation does:
###### Create (POST) - Make something
###### Read (GET)_- Get something
###### Update (PUT) - Change something
###### Delete (DELETE)- Remove something

 [![crud-express-mongo](crud-express-mongo "crud-express-mongo")](https://github.com/NadyaHristuk/Node.js/blob/master/Day_2/crud-express-mongo.png?raw=true "crud-express-mongo")
 
If we put CRUD, Express and MongoDB together into a single diagram, this is what it would look like:
https://en.wikipedia.org/wiki/Create,_read,_update_and_delete

### HTTP-метод имеет значение
Если Вы до сих пор не использовали в своей работе данный подход, то просто запомните - HTTP-метод имеет значение. Так, например, в прошлой части руководства мы определили следующий метод:
```javascript
app.get('/', function(req, res) {
  // Ответ на GET для '/'
  // ...
});
```
Если Вы создадите форму, которая будет выполнять POST для того же URL, то Express будет возвращать ошибку, так как не задан соответствующий обработчик.

#### Справочник CRUD заглушек
Вот как должны выглядеть CRUD заглушки:
```javascript
// Список
app.get('/documents.:format', function(req, res) {
});

// Создать
app.post('/documents.:format?', function(req, res) {
});

// Прочитать
app.get('/documents/:id.:format?', function(req, res) {
});

// Изменить
app.put('/documents/:id.:format?', function(req, res) {
});

// Удалить
app.del('/documents/:id.:format?', function(req, res) {
});

```

**Обратите внимание, что Express использует del вместо delete.**

Задание соответствия между разными HTTP-запросами и разными частями нашего кода называется «маршрутизация» («routing», роутинг). Давайте тогда создадим модуль под названием router.

